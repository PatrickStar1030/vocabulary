<!DOCTYPE html>
<html>
  <head>
    <title>iSpacs Viewer å½“å‰æµè§ˆå™¨æ£€æµ‹æ”¯æŒ</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
      }

      .test-item {
        margin: 10px 0;
        padding: 10px;
        border-radius: 5px;
        background: #f5f5f5;
      }

      .pass {
        color: #0a0;
        font-weight: bold;
      }

      .fail {
        color: #a00;
        font-weight: bold;
      }

      #glCanvas {
        border: 1px solid #ccc;
        margin: 20px 0;
        display: block;
      }

      #finalResult {
        padding: 15px;
        margin-top: 20px;
        font-size: 1.2em;
        text-align: center;
      }

      .hardware-accelerated {
        background: #dfd;
        border: 2px solid #0a0;
      }

      .software-rendering {
        background: #fdd;
        border: 2px solid #a00;
      }

      .performance-value {
        font-weight: bold;
        color: #05a;
      }

      #loading {
        color: #666;
        font-style: italic;
      }

      .benchmark-details {
        margin-top: 10px;
        padding: 10px;
        background: #f9f9f9;
        border-left: 3px solid #05a;
        font-size: 0.9em;
      }

      .tier-info {
        margin: 5px 0;
        padding: 5px;
        border-radius: 3px;
      }

      .tier-excellent { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
      .tier-good { background: #d1ecf1; color: #0c5460; border-left: 4px solid #17a2b8; }
      .tier-acceptable { background: #fff3cd; color: #856404; border-left: 4px solid #ffc107; }
      .tier-poor { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
    </style>
  </head>

  <body>
    <h1>iSpacs Viewer å½“å‰æµè§ˆå™¨æ£€æµ‹æ”¯æŒ</h1>
    <p>å¿…é¡»é€šè¿‡å…¨éƒ¨äº”é¡¹æ£€æµ‹æ‰èƒ½ç¡®è®¤æ”¯æŒæ‰€æœ‰åŠŸèƒ½</p>

    <canvas id="glCanvas" width="512" height="512"></canvas>
    <div id="loading">æ­£åœ¨æ£€æµ‹ä¸­,è¯·ç¨å€™...</div>
    <div id="testResults"></div>
    <div id="finalResult"></div>

    <script>
      // VTKæ€§èƒ½åŸºå‡†é…ç½®
      const VTK_BENCHMARK_CONFIG = {
        // æ ‡å‡†åŒ–æµ‹è¯•å‚æ•°
        canvasSize: 512,           // å›ºå®šåˆ†è¾¨ç‡
        testDuration: 3000,        // 3ç§’æµ‹è¯•(å¢åŠ æµ‹è¯•æ—¶é•¿æé«˜å‡†ç¡®æ€§)
        warmupFrames: 60,          // 60å¸§é¢„çƒ­(ç¡®ä¿GPUè¿›å…¥é«˜æ€§èƒ½çŠ¶æ€)
        
        // VTKå…¸å‹åœºæ™¯å‚æ•° - åŠ å¤§è´Ÿè½½åŒºåˆ†æ€§èƒ½
        triangleCount: 100000,     // å¢åŠ åˆ°10ä¸‡ä¸‰è§’å½¢
        complexShaderOps: 20,      // å¤æ‚ç€è‰²å™¨è¿ç®—æ¬¡æ•°
        textureSize: 2048,         // 2Kçº¹ç†
        lightCount: 4,             // 4ä¸ªåŠ¨æ€å…‰æº
        
        // ä¸¥æ ¼çš„æ€§èƒ½åˆ†çº§æ ‡å‡†
        tiers: {
          excellent: {
            minFPS: 55,
            minScore: 80,
            color: 'tier-excellent',
            description: 'ğŸš€ é«˜æ€§èƒ½æœºå™¨ - æ— å‹åŠ›è¿è¡ŒVTKç¨‹åº(å¤§å‹åŒ»ç–—æ¨¡å‹ã€å¤æ‚åœºæ™¯ã€æµç•…äº¤äº’)'
          },
          good: {
            minFPS: 40,
            minScore: 60,
            color: 'tier-good',
            description: 'âœ“ è‰¯å¥½æ€§èƒ½ - å¯ä»¥è¿è¡ŒVTKç¨‹åº(å¸¸è§„åŒ»ç–—æ¨¡å‹ã€æ ‡å‡†åœºæ™¯)'
          },
          acceptable: {
            minFPS: 25,
            minScore: 50,
            color: 'tier-acceptable',
            description: 'âš  å‹‰å¼ºå¯ç”¨ - å‹‰å¼ºå¯ä»¥è¿è¡Œ(ç®€å•åœºæ™¯ã€å¯èƒ½å¡é¡¿)'
          },
          poor: {
            minFPS: 0,
            minScore: 0,
            color: 'tier-poor',
            description: 'âœ˜ æ€§èƒ½ä¸è¶³ - ä¸èƒ½è¿è¡Œæˆ–ä¸èƒ½æµç•…è¿è¡ŒVTKç¨‹åº'
          }
        }
      };

      async function runReliableDetection() {
        const canvas = document.getElementById("glCanvas");
        const testResults = document.getElementById("testResults");
        const finalResult = document.getElementById("finalResult");
        const loading = document.getElementById("loading");

        // ç¡®ä¿Canvaså°ºå¯¸ä¸€è‡´
        canvas.width = VTK_BENCHMARK_CONFIG.canvasSize;
        canvas.height = VTK_BENCHMARK_CONFIG.canvasSize;

        try {
          // 1. åˆå§‹åŒ–WebGL2
          const gl = canvas.getContext("webgl2", {
            antialias: false,
            preserveDrawingBuffer: true,
            powerPreference: "high-performance"  // å¼ºåˆ¶é«˜æ€§èƒ½æ¨¡å¼
          });
          
          if (!gl) {
            testResults.innerHTML =
              '<div class="test-item fail">âœ˜ æµè§ˆå™¨ä¸æ”¯æŒWebGL2</div>';
            loading.style.display = "none";
            return;
          }

          // 2. è·å–æ¸²æŸ“å™¨ä¿¡æ¯
          const debugExt = gl.getExtension("WEBGL_debug_renderer_info");
          let vendor = "æœªçŸ¥", renderer = "æœªçŸ¥";
          if (debugExt) {
            vendor = gl.getParameter(debugExt.UNMASKED_VENDOR_WEBGL) || vendor;
            renderer = gl.getParameter(debugExt.UNMASKED_RENDERER_WEBGL) || renderer;
          }

          // 3. GPUä¿¡æ¯è¯†åˆ«(æ”¹è¿›ç‰ˆ)
          const gpuInfo = identifyGPU(renderer, vendor);

          // 4. è¿è¡Œæ‰€æœ‰æµ‹è¯•
          const tests = [
            {
              name: "æµè§ˆå™¨ç‰ˆæœ¬æ£€æµ‹",
              check: () => checkBrowserVersion(),
              description: "æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦ä¸º109ä»¥ä¸Šedgeæˆ–è€…chrome(ä¸åŒ…å«109)",
            },
            {
              name: "æ¸²æŸ“å™¨æ£€æµ‹",
              check: () => checkRenderer(renderer),
              description: "æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥è½¯ä»¶æ¸²æŸ“å™¨",
            },
            {
              name: "é«˜æ€§èƒ½ç‰¹æ€§æ£€æµ‹",
              check: () => checkHighPerfFeatures(gl),
              description: "æ£€æŸ¥æ˜¯å¦æ”¯æŒ2ä¸ªä»¥ä¸Šé«˜æ€§èƒ½æ‰©å±•",
            },
            {
              name: "å¤§çº¹ç†æ”¯æŒ",
              check: () => gl.getParameter(gl.MAX_TEXTURE_SIZE) >= 8192,
              description: "æ£€æŸ¥æ˜¯å¦æ”¯æŒ8192x8192ä»¥ä¸Šçº¹ç†",
            },
            {
              name: "VTKæ€§èƒ½åŸºå‡†æµ‹è¯•",
              check: async () => {
                return await runVTKBenchmark(gl, gpuInfo);
              },
              description: "æ¨¡æ‹ŸVTKå…¸å‹åœºæ™¯è¿›è¡Œç»¼åˆæ€§èƒ½è¯„ä¼°",
            },
          ];

          // 5. æ‰§è¡Œå¹¶æ˜¾ç¤ºæ‰€æœ‰æµ‹è¯•
          let allPassed = true;
          testResults.innerHTML = "";

          for (const test of tests) {
            const result = await (typeof test.check === "function"
              ? test.check()
              : test.check);
            const passed = result.passed !== undefined ? result.passed : result;

            if (!passed) allPassed = false;

            let testHtml = `
              <div class="test-item">
                <strong>${test.name}:</strong> 
                <span class="${passed ? "pass" : "fail"}">
                  ${passed ? "âœ“ é€šè¿‡" : "âœ˜ æœªé€šè¿‡"}
                </span>
                <div><small>${test.description}</small></div>
            `;

            if (result.details) {
              testHtml += result.details;
            }

            testHtml += `</div>`;
            testResults.innerHTML += testHtml;

            renderSimpleScene(gl);
          }

          // 6. æ˜¾ç¤ºæœ€ç»ˆç»“æœ
          finalResult.className = allPassed
            ? "hardware-accelerated"
            : "software-rendering";
          finalResult.innerHTML = allPassed
            ? "<h2>âœ“ ç¡¬ä»¶åŠ é€Ÿç¡®è®¤å·²å¯ç”¨</h2><p>æ‰€æœ‰æ£€æµ‹é¡¹ç›®å‡é€šè¿‡</p>"
            : "<h2>âœ˜ æœªå¯ç”¨ç¡¬ä»¶åŠ é€Ÿ</h2><p>æœªé€šè¿‡å…¨éƒ¨æ£€æµ‹</p>";

          // æ˜¾ç¤ºè¯¦ç»†é…ç½®ä¿¡æ¯
          testResults.innerHTML += `
            <div class="test-item">
              <h3>ç³»ç»Ÿä¿¡æ¯</h3>
              <p><strong>æ˜¾å¡ä¾›åº”å•†:</strong> ${vendor}</p>
              <p><strong>æ¸²æŸ“å™¨:</strong> ${renderer}</p>
              <p><strong>GPUè¯†åˆ«:</strong> ${gpuInfo.name} (${gpuInfo.tier})</p>
              <p><strong>æµè§ˆå™¨ç‰ˆæœ¬:</strong> ${navigator.userAgent}</p>
              <p><strong>WebGLç‰ˆæœ¬:</strong> ${gl.getParameter(gl.VERSION)}</p>
              <p><strong>æœ€å¤§çº¹ç†å°ºå¯¸:</strong> ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}</p>
              <p><strong>æœ€å¤§æ¸²æŸ“ç¼“å†²å°ºå¯¸:</strong> ${gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)}</p>
              <p><strong>æœ€å¤§é¡¶ç‚¹å±æ€§:</strong> ${gl.getParameter(gl.MAX_VERTEX_ATTRIBS)}</p>
            </div>
          `;

          loading.style.display = "none";
          renderColorfulScene(gl);
        } catch (error) {
          loading.style.display = "none";
          testResults.innerHTML = `<div class="test-item fail">æ£€æµ‹å‡ºé”™: ${error.message}</div>`;
        }
      }

      // GPUè¯†åˆ«å‡½æ•°(æ›´ä¸¥æ ¼çš„æ€§èƒ½é¢„æœŸ)
      function identifyGPU(renderer, vendor) {
        const r = renderer.toLowerCase();
        const v = vendor.toLowerCase();
        
        // NVIDIA GPUè¯†åˆ«
        if (r.includes('nvidia') || v.includes('nvidia')) {
          if (r.includes('rtx')) {
            const match = r.match(/rtx\s*(\d+)/i);
            if (match) {
              const model = parseInt(match[1]);
              if (model >= 5000) return { name: `NVIDIA RTX ${model}`, tier: 'High-End', expectedScore: 95 };
              if (model >= 4000) return { name: `NVIDIA RTX ${model}`, tier: 'High-End', expectedScore: 90 };
              if (model >= 3000) return { name: `NVIDIA RTX ${model}`, tier: 'High-End', expectedScore: 85 };
              if (model >= 2000) return { name: `NVIDIA RTX ${model}`, tier: 'Mid-Range', expectedScore: 75 };
            }
          }
          if (r.includes('gtx')) {
            const match = r.match(/gtx\s*(\d+)/i);
            if (match) {
              const model = parseInt(match[1]);
              if (model >= 1600) return { name: `NVIDIA GTX ${model}`, tier: 'Mid-Range', expectedScore: 70 };
              return { name: `NVIDIA GTX ${model}`, tier: 'Entry-Level', expectedScore: 60 };
            }
          }
          if (r.includes('quadro') || r.includes('tesla')) {
            return { name: 'NVIDIA Professional', tier: 'High-End', expectedScore: 85 };
          }
          return { name: 'NVIDIA GPU', tier: 'Unknown', expectedScore: 65 };
        }
        
        // AMD GPUè¯†åˆ«
        if (r.includes('amd') || r.includes('radeon') || v.includes('amd')) {
          if (r.includes('rx')) {
            const match = r.match(/rx\s*(\d+)/i);
            if (match) {
              const model = parseInt(match[1]);
              if (model >= 7000) return { name: `AMD RX ${model}`, tier: 'High-End', expectedScore: 88 };
              if (model >= 6000) return { name: `AMD RX ${model}`, tier: 'High-End', expectedScore: 82 };
              if (model >= 5000) return { name: `AMD RX ${model}`, tier: 'Mid-Range', expectedScore: 72 };
            }
          }
          if (r.includes('vega')) return { name: 'AMD Vega', tier: 'Mid-Range', expectedScore: 68 };
          if (r.includes('pro')) return { name: 'AMD Pro', tier: 'Professional', expectedScore: 78 };
          
          // AMDé›†æˆæ˜¾å¡
          if (r.includes('radeon(tm) graphics') || r.includes('radeon graphics')) {
            return { name: 'AMD Integrated Graphics', tier: 'Integrated', expectedScore: 35 };
          }
          return { name: 'AMD GPU', tier: 'Unknown', expectedScore: 60 };
        }
        
        // Intel GPUè¯†åˆ«
        if (r.includes('intel') || v.includes('intel')) {
          if (r.includes('arc')) {
            const match = r.match(/arc\s*[a-z]*(\d+)/i);
            if (match) {
              const model = parseInt(match[1]);
              if (model >= 700) return { name: `Intel Arc A${model}`, tier: 'Mid-Range', expectedScore: 75 };
              return { name: `Intel Arc A${model}`, tier: 'Entry-Level', expectedScore: 65 };
            }
          }
          if (r.includes('iris xe')) {
            return { name: 'Intel Iris Xe', tier: 'Integrated', expectedScore: 45 };
          }
          if (r.includes('uhd') || r.includes('hd graphics')) {
            const match = r.match(/(\d+)/);
            if (match) {
              const model = parseInt(match[0]);
              if (model >= 700) return { name: `Intel UHD ${model}`, tier: 'Integrated', expectedScore: 38 };
            }
            return { name: 'Intel UHD Graphics', tier: 'Integrated', expectedScore: 30 };
          }
          return { name: 'Intel Integrated', tier: 'Integrated', expectedScore: 32 };
        }
        
        return { name: 'Unknown GPU', tier: 'Unknown', expectedScore: 50 };
      }

      // VTKæ€§èƒ½åŸºå‡†æµ‹è¯•(æ›´ä¸¥æ ¼çš„è¯„åˆ†)
      async function runVTKBenchmark(gl, gpuInfo) {
        return new Promise((resolve) => {
          const config = VTK_BENCHMARK_CONFIG;
          const results = {
            fps: 0,
            avgFrameTime: 0,
            minFrameTime: Infinity,
            maxFrameTime: 0,
            frames: 0,
            drawCalls: 0,
            pixelFillRate: 0,
            vertexThroughput: 0
          };

          // åˆ›å»ºVTKå¤æ‚åœºæ™¯ç¨‹åº
          const program = createVTKComplexSceneProgram(gl);
          gl.useProgram(program);

          // è®¾ç½®å¤§é‡é¡¶ç‚¹æ•°æ®
          const vertexCount = config.triangleCount * 3;
          const vertices = generateComplexMesh(vertexCount);
          const normals = generateNormals(vertexCount);
          
          const vertexBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
          
          const normalBuffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
          gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

          const positionLoc = gl.getAttribLocation(program, "position");
          const normalLoc = gl.getAttribLocation(program, "normal");
          
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.enableVertexAttribArray(positionLoc);
          gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
          gl.enableVertexAttribArray(normalLoc);
          gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);

          // åˆ›å»ºçº¹ç†å¢åŠ è´Ÿè½½
          const texture = createComplexTexture(gl, config.textureSize);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.uniform1i(gl.getUniformLocation(program, "uTexture"), 0);

          // å¯ç”¨æ·±åº¦æµ‹è¯•å’Œæ··åˆ
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(gl.LEQUAL);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

          let frameCount = 0;
          let startTime = 0;
          let lastFrameTime = 0;
          let isWarmup = true;
          const frameTimes = [];
          let totalPixels = 0;
          let totalVertices = 0;

          function benchmarkLoop(timestamp) {
            if (frameCount === 0) {
              startTime = timestamp;
              lastFrameTime = timestamp;
            }

            const frameTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;

            if (!isWarmup && frameTime > 0) {
              frameTimes.push(frameTime);
              results.minFrameTime = Math.min(results.minFrameTime, frameTime);
              results.maxFrameTime = Math.max(results.maxFrameTime, frameTime);
            }

            const time = (timestamp - startTime) * 0.001;
            
            // æ›´æ–°å¤æ‚çš„uniforms
            gl.uniform1f(gl.getUniformLocation(program, "time"), time);
            gl.uniform1f(gl.getUniformLocation(program, "complexity"), config.complexShaderOps);
            
            // å¤šä¸ªåŠ¨æ€å…‰æº
            for (let i = 0; i < config.lightCount; i++) {
              const angle = time * 0.5 + (i * Math.PI * 2 / config.lightCount);
              gl.uniform3fv(gl.getUniformLocation(program, `lights[${i}]`), 
                [Math.sin(angle) * 3, 2 + Math.sin(time * 0.3) * 1, Math.cos(angle) * 3]);
            }

            // æ¸…é™¤ç¼“å†²
            gl.clearColor(0.05, 0.05, 0.1, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // å¤šæ¬¡ç»˜åˆ¶è°ƒç”¨æ¨¡æ‹Ÿå¤æ‚VTKåœºæ™¯
            const drawCallsPerFrame = 8;  // å¢åŠ ç»˜åˆ¶è°ƒç”¨æ¬¡æ•°
            const verticesPerDraw = Math.floor(vertexCount / 2);  // æ¯æ¬¡ç»˜åˆ¶æ›´å¤šé¡¶ç‚¹
            
            for (let i = 0; i < drawCallsPerFrame; i++) {
              gl.uniform1f(gl.getUniformLocation(program, "objectOffset"), i * 0.25);
              gl.uniform1f(gl.getUniformLocation(program, "objectRotation"), time * 0.3 + i * 0.5);
              gl.drawArrays(gl.TRIANGLES, 0, verticesPerDraw);
              results.drawCalls++;
              
              if (!isWarmup) {
                totalVertices += verticesPerDraw;
                totalPixels += config.canvasSize * config.canvasSize;
              }
            }

            frameCount++;

            // é¢„çƒ­é˜¶æ®µ
            if (isWarmup && frameCount >= config.warmupFrames) {
              isWarmup = false;
              frameCount = 0;
              startTime = timestamp;
              frameTimes.length = 0;
              totalPixels = 0;
              totalVertices = 0;
            }

            const elapsed = timestamp - startTime;
            if (!isWarmup && elapsed < config.testDuration) {
              requestAnimationFrame(benchmarkLoop);
            } else if (!isWarmup) {
              // è®¡ç®—è¯¦ç»†ç»“æœ
              results.frames = frameTimes.length;
              results.fps = (results.frames / (elapsed / 1000));
              results.avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
              
              // è®¡ç®—ååé‡
              results.pixelFillRate = (totalPixels / (elapsed / 1000)) / 1000000; // M pixels/s
              results.vertexThroughput = (totalVertices / (elapsed / 1000)) / 1000000; // M vertices/s

              // æ›´ä¸¥æ ¼çš„ç»¼åˆè¯„åˆ†è®¡ç®—
              const fpsScore = Math.min(100, (results.fps / 60) * 100);
              
              // å¸§æ—¶é—´ç¨³å®šæ€§(æ³¢åŠ¨è¶Šå¤§æ‰£åˆ†è¶Šå¤š)
              const frameTimeVariance = ((results.maxFrameTime - results.minFrameTime) / results.avgFrameTime);
              const stabilityScore = Math.max(0, 100 - (frameTimeVariance * 30));
              
              // ç»˜åˆ¶è°ƒç”¨æ•ˆç‡
              const expectedDrawCalls = (config.testDuration / 16.67) * 8;
              const drawCallScore = Math.min(100, (results.drawCalls / expectedDrawCalls) * 100);
              
              // åƒç´ å¡«å……ç‡å¾—åˆ†(åŸºäºGPUç±»å‹è°ƒæ•´)
              const expectedPixelFillRate = gpuInfo.tier === 'High-End' ? 5000 : 
                                           gpuInfo.tier === 'Mid-Range' ? 2000 : 
                                           gpuInfo.tier === 'Integrated' ? 500 : 1000;
              const pixelScore = Math.min(100, (results.pixelFillRate / expectedPixelFillRate) * 100);
              
              // é¡¶ç‚¹ååé‡å¾—åˆ†
              const expectedVertexThroughput = gpuInfo.tier === 'High-End' ? 1000 : 
                                               gpuInfo.tier === 'Mid-Range' ? 500 : 
                                               gpuInfo.tier === 'Integrated' ? 100 : 300;
              const vertexScore = Math.min(100, (results.vertexThroughput / expectedVertexThroughput) * 100);
              
              // ç»¼åˆå¾—åˆ†(æƒé‡åˆ†é…)
              let finalScore = (
                fpsScore * 0.40 +           // FPSæƒé‡40%
                stabilityScore * 0.25 +     // ç¨³å®šæ€§æƒé‡25%
                drawCallScore * 0.15 +      // ç»˜åˆ¶æ•ˆç‡15%
                pixelScore * 0.10 +         // åƒç´ å¡«å……10%
                vertexScore * 0.10          // é¡¶ç‚¹åå10%
              );
              
              // é›†æˆæ˜¾å¡æƒ©ç½šç³»æ•°
              if (gpuInfo.tier === 'Integrated') {
                finalScore = finalScore * 0.7;  // é›†æˆæ˜¾å¡å¾—åˆ†æ‰“7æŠ˜
              }
              
              // å¦‚æœå¸§ç‡è¿‡ä½,è¿›ä¸€æ­¥é™ä½å¾—åˆ†
              if (results.fps < 30) {
                finalScore = finalScore * (results.fps / 30);
              }

              // ç¡®å®šæ€§èƒ½ç­‰çº§
              let tier = 'poor';
              let tierInfo = config.tiers.poor;
              
              if (results.fps >= config.tiers.excellent.minFPS && finalScore >= config.tiers.excellent.minScore) {
                tier = 'excellent';
                tierInfo = config.tiers.excellent;
              } else if (results.fps >= config.tiers.good.minFPS && finalScore >= config.tiers.good.minScore) {
                tier = 'good';
                tierInfo = config.tiers.good;
              } else if (results.fps >= config.tiers.acceptable.minFPS && finalScore >= config.tiers.acceptable.minScore) {
                tier = 'acceptable';
                tierInfo = config.tiers.acceptable;
              }

              const passed = finalScore >= config.tiers.acceptable.minScore;

              // ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
              const scoreBreakdown = `
                <div style="margin-top: 8px; font-size: 0.9em; color: #666;">
                  <strong>å¾—åˆ†æ˜ç»†:</strong><br>
                  â€¢ FPSå¾—åˆ†: ${fpsScore.toFixed(1)} (æƒé‡40%)<br>
                  â€¢ ç¨³å®šæ€§: ${stabilityScore.toFixed(1)} (æƒé‡25%)<br>
                  â€¢ ç»˜åˆ¶æ•ˆç‡: ${drawCallScore.toFixed(1)} (æƒé‡15%)<br>
                  â€¢ åƒç´ å¡«å……: ${pixelScore.toFixed(1)} (æƒé‡10%)<br>
                  â€¢ é¡¶ç‚¹åå: ${vertexScore.toFixed(1)} (æƒé‡10%)
                  ${gpuInfo.tier === 'Integrated' ? '<br>â€¢ é›†æˆæ˜¾å¡æƒ©ç½š: -30%' : ''}
                </div>
              `;

              const details = `
                <div class="benchmark-details">
                  <div class="tier-info ${tierInfo.color}">
                    <strong>æ€§èƒ½è¯„çº§: ${tier.toUpperCase()}</strong> (å¾—åˆ†: ${finalScore.toFixed(1)}/100)<br>
                    ${tierInfo.description}
                  </div>
                  ${scoreBreakdown}
                  <p><strong>å¹³å‡FPS:</strong> ${results.fps.toFixed(1)} å¸§/ç§’ ${results.fps >= 60 ? 'ğŸš€' : results.fps >= 30 ? 'âœ“' : 'âš '}</p>
                  <p><strong>å¸§æ—¶é—´:</strong> ${results.avgFrameTime.toFixed(2)}ms (èŒƒå›´: ${results.minFrameTime.toFixed(2)} - ${results.maxFrameTime.toFixed(2)}ms)</p>
                  <p><strong>å¸§æ—¶é—´æ³¢åŠ¨:</strong> ${frameTimeVariance.toFixed(2)}x ${frameTimeVariance < 0.5 ? '(ç¨³å®šâœ“)' : frameTimeVariance < 1 ? '(ä¸€èˆ¬)' : '(ä¸ç¨³å®šâš )'}</p>
                  <p><strong>æµ‹è¯•å¸§æ•°:</strong> ${results.frames} å¸§ (${config.testDuration/1000}ç§’æµ‹è¯•)</p>
                  <p><strong>ç»˜åˆ¶è°ƒç”¨:</strong> ${results.drawCalls} æ¬¡</p>
                  <p><strong>åƒç´ å¡«å……ç‡:</strong> ${results.pixelFillRate.toFixed(1)} M pixels/s</p>
                  <p><strong>é¡¶ç‚¹ååé‡:</strong> ${results.vertexThroughput.toFixed(1)} M vertices/s</p>
                  <p><strong>GPUä¿¡æ¯:</strong> ${gpuInfo.name} (${gpuInfo.tier})</p>
                  <p><strong>é¢„æœŸå¾—åˆ†:</strong> ${gpuInfo.expectedScore} ${Math.abs(finalScore - gpuInfo.expectedScore) > 15 ? 'âš  å®é™…è¡¨ç°å¼‚å¸¸' : 'âœ“ ç¬¦åˆé¢„æœŸ'}</p>
                  ${Math.abs(finalScore - gpuInfo.expectedScore) > 15 ? 
                    '<p style="color: #d00; margin-top: 8px;"><strong>âš  æ€§èƒ½å¼‚å¸¸è­¦å‘Š:</strong><br>' +
                    (finalScore < gpuInfo.expectedScore ? 
                      'å®é™…æ€§èƒ½ä½äºGPUé¢„æœŸ,å¯èƒ½åŸå› :<br>â€¢ æ˜¾å¡é©±åŠ¨ç‰ˆæœ¬è¿‡æ—§<br>â€¢ æµè§ˆå™¨ç¡¬ä»¶åŠ é€Ÿæœªå¯ç”¨<br>â€¢ ç”µæºç®¡ç†é™åˆ¶GPUæ€§èƒ½<br>â€¢ åå°ç¨‹åºå ç”¨GPUèµ„æº' :
                      'å®é™…æ€§èƒ½é«˜äºé¢„æœŸ,å¯èƒ½æ˜¯GPUè¯†åˆ«ä¸å‡†ç¡®') +
                    '</p>' : ''}
                </div>
              `;

              resolve({
                passed: passed,
                score: finalScore,
                tier: tier,
                details: details
              });
            } else {
              requestAnimationFrame(benchmarkLoop);
            }
          }

          requestAnimationFrame(benchmarkLoop);
        });
      }

      // ç”Ÿæˆå¤æ‚ç½‘æ ¼
      function generateComplexMesh(vertexCount) {
        const vertices = new Float32Array(vertexCount * 3);
        for (let i = 0; i < vertexCount; i++) {
          const angle = (i / vertexCount) * Math.PI * 2;
          const radius = 0.5 + Math.random() * 0.3;
          vertices[i * 3] = Math.cos(angle) * radius;
          vertices[i * 3 + 1] = Math.sin(angle) * radius;
          vertices[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
        }
        return vertices;
      }

      // ç”Ÿæˆæ³•çº¿æ•°æ®
      function generateNormals(vertexCount) {
        const normals = new Float32Array(vertexCount * 3);
        for (let i = 0; i < vertexCount; i++) {
          const angle = (i / vertexCount) * Math.PI * 2;
          normals[i * 3] = Math.cos(angle);
          normals[i * 3 + 1] = Math.sin(angle);
          normals[i * 3 + 2] = Math.sin(angle * 3) * 0.3;
        }
        return normals;
      }

      // åˆ›å»ºå¤æ‚çº¹ç†
      function createComplexTexture(gl, size) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        
        const data = new Uint8Array(size * size * 4);
        for (let i = 0; i < size * size; i++) {
          const x = i % size;
          const y = Math.floor(i / size);
          data[i * 4 + 0] = ((x ^ y) * 2) % 255;
          data[i * 4 + 1] = ((x + y) * 3) % 255;
          data[i * 4 + 2] = ((x * y) / 10) % 255;
          data[i * 4 + 3] = 255;
        }
        
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.generateMipmap(gl.TEXTURE_2D);
        
        return texture;
      }

      // åˆ›å»ºVTKå¤æ‚åœºæ™¯ç€è‰²å™¨
      function createVTKComplexSceneProgram(gl) {
        const vs = `#version 300 es
          in vec3 position;
          in vec3 normal;
          uniform float time;
          uniform float objectOffset;
          uniform float objectRotation;
          out vec3 vNormal;
          out vec3 vPosition;
          out vec2 vTexCoord;
          
          mat3 rotationMatrix(float angle) {
            float s = sin(angle);
            float c = cos(angle);
            return mat3(
              c, 0.0, s,
              0.0, 1.0, 0.0,
              -s, 0.0, c
            );
          }
          
          void main() {
            mat3 rot = rotationMatrix(objectRotation);
            vec3 rotated = rot * position;
            vec3 offset = vec3(objectOffset * sin(time * 0.3), 0.0, 0.0);
            vec3 finalPos = rotated * 0.6 + offset;
            
            vPosition = finalPos;
            vNormal = normalize(rot * normal);
            vTexCoord = (position.xy + 1.0) * 0.5;
            gl_Position = vec4(finalPos, 1.0);
          }`;

        const fs = `#version 300 es
          precision highp float;
          uniform float time;
          uniform float complexity;
          uniform vec3 lights[4];
          uniform sampler2D uTexture;
          
          in vec3 vNormal;
          in vec3 vPosition;
          in vec2 vTexCoord;
          out vec4 fragColor;
          
          // å¤æ‚çš„å…‰ç…§è®¡ç®—
          vec3 calculateLighting(vec3 normal, vec3 position, vec3 lightPos) {
            vec3 lightDir = normalize(lightPos - position);
            float diff = max(dot(normal, lightDir), 0.0);
            
            vec3 viewDir = normalize(-position);
            vec3 halfDir = normalize(lightDir + viewDir);
            float spec = pow(max(dot(normal, halfDir), 0.0), 64.0);
            
            float distance = length(lightPos - position);
            float attenuation = 1.0 / (1.0 + 0.5 * distance + 0.3 * distance * distance);
            
            return (diff + spec * 0.5) * attenuation;
          }
          
          // å¢åŠ ç€è‰²å™¨å¤æ‚åº¦çš„å‡½æ•°
          float complexCalculation(vec2 uv, float t) {
            float result = 0.0;
            for (int i = 0; i < int(complexity); i++) {
              float fi = float(i);
              result += sin(uv.x * fi + t) * cos(uv.y * fi + t) * 0.1;
            }
            return result;
          }
          
          void main() {
            vec3 normal = normalize(vNormal);
            
            // å¤šå…‰æºç´¯åŠ 
            vec3 totalLight = vec3(0.0);
            for (int i = 0; i < 4; i++) {
              totalLight += calculateLighting(normal, vPosition, lights[i]);
            }
            
            // çº¹ç†é‡‡æ ·
            vec4 texColor = texture(uTexture, vTexCoord);
            
            // å¤æ‚è®¡ç®—å¢åŠ GPUè´Ÿè½½
            float complexity_factor = complexCalculation(vTexCoord, time);
            
            // åŸºç¡€é¢œè‰²
            vec3 baseColor = vec3(0.2, 0.4, 0.7) + texColor.rgb * 0.3;
            
            // ç¯å¢ƒå…‰
            vec3 ambient = baseColor * 0.15;
            
            // æœ€ç»ˆé¢œè‰²
            vec3 finalColor = ambient + baseColor * totalLight * 0.6 + vec3(complexity_factor * 0.1);
            
            // æ·»åŠ è¾¹ç¼˜å…‰
            float rim = pow(1.0 - max(dot(normal, normalize(-vPosition)), 0.0), 3.0);
            finalColor += vec3(rim * 0.3);
            
            fragColor = vec4(finalColor, 1.0);
          }`;

        return compileProgram(gl, vs, fs);
      }

      // æ¸²æŸ“ç®€å•åœºæ™¯ä¿æŒæ˜¾ç¤º
      function renderSimpleScene(gl) {
        const program = createSimpleProgram(gl);
        gl.useProgram(program);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        gl.clearColor(0.9, 0.9, 0.9, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      // æ¸²æŸ“å½©è‰²åœºæ™¯ä½œä¸ºæœ€ç»ˆæ˜¾ç¤º
      function renderColorfulScene(gl) {
        const program = createColorfulProgram(gl);
        gl.useProgram(program);

        const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        const timeLoc = gl.getUniformLocation(program, "time");
        gl.uniform1f(timeLoc, performance.now() * 0.001);

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      function checkBrowserVersion() {
        const agent = navigator.userAgent;
        if (!/Chrome\//.test(agent) && !/Edg\//.test(agent)) {
          return false;
        }
        if (
          (agent.match(/Chrome\/(\d+)/) &&
            parseInt(agent.match(/Chrome\/(\d+)/)[1]) <= 109) ||
          (agent.match(/Edg\/(\d+)/) &&
            parseInt(agent.match(/Edg\/(\d+)/)[1]) <= 109)
        ) {
          return false;
        }
        return true;
      }

      // ä¸¥æ ¼çš„æ¸²æŸ“å™¨æ£€æµ‹
      function checkRenderer(renderer) {
        const softwareRenderers = [
          "SwiftShader",
          "Google SwiftShader",
          "llvmpipe",
          "softpipe",
          "WARP",
          "Microsoft Basic Render Driver",
          "SVGA3D",
          "VirtualBox",
          "VMware",
        ];

        if (!renderer || renderer === "æœªçŸ¥") return false;
        return !softwareRenderers.some((name) => renderer.includes(name));
      }

      // é«˜æ€§èƒ½ç‰¹æ€§æ£€æµ‹
      function checkHighPerfFeatures(gl) {
        const highPerfExtensions = [
          "EXT_color_buffer_float",
          "OES_texture_float_linear",
          "EXT_texture_filter_anisotropic",
          "WEBGL_draw_buffers",
        ];
        return (
          highPerfExtensions.filter((ext) => gl.getExtension(ext)).length >= 2
        );
      }

      // åˆ›å»ºç®€å•ç¨‹åº
      function createSimpleProgram(gl) {
        const vs = `#version 300 es
          in vec2 position;
          void main() { gl_Position = vec4(position, 0, 1); }`;

        const fs = `#version 300 es
          precision highp float;
          out vec4 fragColor;
          void main() { fragColor = vec4(0.8, 0.8, 0.8, 1.0); }`;

        return compileProgram(gl, vs, fs);
      }

      // åˆ›å»ºå½©è‰²ç¨‹åº
      function createColorfulProgram(gl) {
        const vs = `#version 300 es
          in vec2 position;
          void main() { gl_Position = vec4(position, 0, 1); }`;

        const fs = `#version 300 es
          precision highp float;
          uniform float time;
          out vec4 fragColor;
          void main() {
            vec2 uv = gl_FragCoord.xy / vec2(512.0);
            fragColor = vec4(
              0.5 + 0.5 * sin(time + uv.x * 5.0),
              0.5 + 0.5 * cos(time + uv.y * 5.0),
              0.5 + 0.5 * sin(time * 1.5 + (uv.x + uv.y) * 2.0),
              1.0
            );
          }`;

        return compileProgram(gl, vs, fs);
      }

      // ç¼–è¯‘ç€è‰²å™¨ç¨‹åº
      function compileProgram(gl, vsSource, fsSource) {
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fsSource);
        gl.compileShader(fs);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        return program;
      }

      // å¯åŠ¨æ£€æµ‹
      runReliableDetection();
    </script>
  </body>
</html>